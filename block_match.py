import numpy as np
import skimage as ski

import numpy.random
import scipy.spatial.distance
import skimage.util
import matplotlib.pyplot as plt


def block_match_self(y, ref_coordinates, n1=8, n2=32):
    """
    Block match for self-similarity.
    
    Compute a match table using as search space the same image from where the
    reference block is extracted. The reference block is specified as a tuple of
    coordinates (row,col).
    
    :param y: Input image. Can be grayscale or colour.
    
    :param ref_coordinates: Tuple of reference block coordinates in the form 
    (row, col). row and col must be of the same size, either scalar or some 
    sort of array. If row/col are an array, multiple reference blocks are 
    processed simultaneously.
    
    :param n1: Edge of the patch (first 2 dimensions).
    
    :param n2: Group size. Number of similar patches returned in the match 
    table, per reference block.
    
    :return: Match table. A tuple (row, col). Both row and col are of 
    dimensions (ref_coordinates[0].shape, n2). 
    """

    patch_shape = compute_patch_shape(y, n1)

    # Search is performed in all patches of size patch_shape present in the
    # input image. search_space is a view of the input image y that contains all
    # such patches.
    search_space = skimage.util.view_as_windows(y, patch_shape)

    # Reference patches are all patches requested by the user. Requested
    # coordinates point to the top left corner of the patch in y.
    ref = search_space[ref_coordinates]

    # Flatten arrays for distance computation.
    ref_flat = ref.reshape(-1, np.prod(search_space.shape[y.ndim:]))
    search_space_flat = search_space.reshape(np.prod(search_space.shape[:y.ndim]),
                                             np.prod(search_space.shape[y.ndim:]))

    # Compute pairwise distance between reference blocks and the search space.
    distance = scipy.spatial.distance.cdist(ref_flat, search_space_flat)

    # Sort and truncate.
    sel = np.argpartition(distance, n2)[:, :n2]

    # Return as a tuple (row, col)
    match_table = np.unravel_index(sel, search_space.shape[:2])

    return match_table


def block_match_local(y, ref_coordinates, n1=8, n2=8, ns=8, max_memory=2**30):

   patch_shape = compute_patch_shape(y, n1)

   # View image as patches.
   y_patch = ski.util.view_as_windows(y, patch_shape)

   # Reference coordinate arrays are flattened.
   ref_row = np.array(ref_coordinates[0], ndmin=1).reshape(-1, 1)
   ref_col = np.array(ref_coordinates[1], ndmin=1).reshape(-1, 1)

   candidate_coordinates = np.mgrid[0:ns,0:ns].reshape(2, 1, -1)
   candidate_row = ref_row + candidate_coordinates[0]
   candidate_col = ref_col + candidate_coordinates[1]

   # View of reference blocks and corresponding search space.
   ref = y_patch[(ref_row, ref_col)]
   search_space = y_patch[(candidate_row, candidate_col)]

   # Compute non rooted Euclidean distance.
   difference = search_space - ref
   distance = np.sum(difference ** 2, axis=(2, 3))

   # Find n2 best distances.
   match_idx = np.argpartition(distance, n2)[..., :n2]

   # Compute global coordinates.
   match_row, match_col = np.unravel_index(match_idx, (ns, ns))
   match_row = ref_row + match_row
   match_col = ref_col + match_col

   # Match table is a (row, col) tupple.
   match_table = (match_row, match_col)

   # Distance is 2D for simplicity of interpretation.
   distance = distance.reshape((-1, ns, ns,))

   return match_table, distance


def read_group(y, match_table, n1=8):
    """
    Read a group of patches from image based on match table.
    
    :param y: Image to read patches from.
    
    :param match_table: Match table used to extract patches, generated by 
    block_match_self().
    
    :param n1: Edge of the patch (first 2 dimensions).
    
    :return: Group(s) of patches. View on the input image of shape
    (match_table[0].shape, compute_patch_shape(y, n1)). In practical terms, 
    for grayscale images, the shape is (group_index, patch_index, row, column). 
    """

    patch_shape = compute_patch_shape(y, n1)
    group = skimage.util.view_as_windows(y, patch_shape)[match_table]

    return group


def compute_patch_shape(y, n1):
    """
    Compute shape of patch on input image y.
    
    The shape of a patch is only partially determined by n1, the edge of the 
    patch. For input images of dimension greater than 2, say, colour images, 
    the shape of the patch must include the number of channels. This function
    generates a proper shape tupple taking into account all this.
    
    :param y: Input image which dimensions are to be taken into account.
    
    :param n1: Edge of the patch, for the first 2 dimensions.
    
    :return: Tuple containing patch shape.
    """

    # A patch is n1 by n1 by whatever number of "channels" y has. Usually y
    # has 1 channel, but this should be general.
    if y.ndim > 2:
        patch_shape = (n1, n1, y.shape[2:])
    else:
        patch_shape = (n1, n1)

    return patch_shape


def visualise_match_table(match_table, y, n1=8, ref_coordinates=None,
                          distance=None):

    # 3rd dimension addresses the matches
    group_count_row, group_count_col, n2 = match_table[0].shape

    # Pick a random group. A group id is a (row, col) tuple of coordinates in
    #  the match table's two first dimensions.
    group_id = (np.random.randint(group_count_row),
                np.random.randint(group_count_col), )

    match_entry = (match_table[0][group_id], match_table[1][group_id], )
    group = read_group(y, match_entry, n1)

    if distance is not None:
        distance_entry = distance[group_id]
        axis_count = n2 + 1
    else:
        axis_count = n2

    if ref_coordinates is not None:
        ref_row = ref_coordinates[0][group_id]
        ref_col = ref_coordinates[1][group_id]
    else:
        ref_row = -1
        ref_col = -1

    # Show results.
    axis_count_root = np.ceil(np.sqrt(axis_count))
    plt.figure(figsize=(axis_count_root, axis_count_root))
    plt.set_cmap('gray')
    for r in range(n2):
        b = group[r]
        row = match_entry[0][r]
        col = match_entry[1][r]
        plt.subplot(axis_count_root, axis_count_root, r + 1)
        plt.imshow(b)

        if distance is not None:
            d = distance_entry[np.unravel_index(r, match_entry[0].shape)]
            tt = plt.title('(%s,%s: %0.6f)' % (row, col, d))
        else:
            tt = plt.title('(%s,%s)' % (match_entry[0][r], match_entry[1][r]))

        if (row_rel, col_rel) == (0, 0):
            tt.set_color('red')

    if distance is not None:
        plt.subplot(axis_count_root, axis_count_root, axis_count)
        plt.imshow(distance_entry)
        plt.title('Distance matrix')

    plt.show()
